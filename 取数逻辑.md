# OpenFE
      
### utils

```get_secucode(start, end)```:从```SmartQuant.ReturnDaily```中获取SecuCode List

```get_month_first_trading_day(start, end)```: 从 ```SmartQuant.CalenderDay_TradingDay```中获取每月首日数据列表

```get_trading_day(start, end, margins=0)``` :获取[start , end + margin] 的交易日列表
      
### read
```read_Fundamental(date, name)```:
         
            read_parquet("./Fundamental/Lib/{}/{}.parquet".format(name, date))

            data[name].values.reshape(-1, 12): 时间序列数据按固定窗口切分 (N,) -> (N//12, 12,)
            
            每行代表一个证券、每列代表一个月份
            
### process
```process_Fundamental(date, name, secucode)```：

Q： ```feature_name = name[12:]```是什么？？？   是不是没有对['CumLatest', 'Quarterly', 'TTM']的不同数据进行处理？

- 从 ./Fundamental/raw/{指标名称}/{日期}.parquet 读取原始财务数据。

            数据包含列：CumLatest（累计值）、Quarterly（季度值）、TTM（滚动年度值）、DataDate（数据日期）、InnerCode（内部代码）等。

- 映射证券代码：读取 InnerCode 到 SecuCode 的映射关系，将财务数据的 InnerCode 转换为标准的 SecuCode（证券代码）

            删除无法映射到有效证券代码的行。

- 按财务期间处理数据（循环12次）

            subset = data.loc[data['EndDateRank']==i+1]    
            创建一个与 secucode 长度相同的空 DataFrame（用 NaN 填充）    
            如果证券代码在当前月份有数据，则填充；否则保持 NaN
  
- 拼接数据：排序后最终存储为结构化格式，传递给```save_Fundamental(new_data, date, feature_name)```

### save
```save_Fundamental(data, date, feature_name)```
- 对每列财务指标（累计值、季度值、滚动年度值）分别处理
-  提取关键列并重命名
  
            df = data[['DataDate', 'SecuCode', 'EndDateRank', col]]
   
            df = df.rename({col: '{}_{}'.format(feature_name, col)}, axis=1) 需要一点example
   
            将处理后的 DataFrame 保存为 Parquet 文件，路径格式为：
   
            df.to_parquet("./Fundamental/Lib/{}_{}/{}.parquet".format(feature_name, col, date), index=False)
```text
./Fundamental/Lib/
    ├── ROE_CumLatest/
    │   └── 20230812.parquet
    ├── ROE_Quarterly/
    │   └── 20230812.parquet
    └── ROE_TTM/
        └── 20230812.parquet
```
### DataProvider:
