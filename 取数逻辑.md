# OpenFE
      
### utils

```get_secucode(start, end)```:从```SmartQuant.ReturnDaily```中获取SecuCode List

```get_month_first_trading_day(start, end)```: 从 ```SmartQuant.CalenderDay_TradingDay```中获取每月首日数据列表

```get_trading_day(start, end, margins=0)``` :获取[start , end + margin] 的交易日列表

### download
```download_Fundamental(date, name, mode='sqlserver')```
- 从指定的数据库（SQL Server 或 OceanBase）下载财务基本面数据，并保存为本地 Parquet 文件。
- data.to_parquet(os.path.join("./Fundamental/raw", name, "{}.parquet".format(date)), index=False)
Q:load_dotenv()是什么？？？

### process
```process_Fundamental(date, name, secucode)```：

Q： ```feature_name = name[12:]```是什么？？？   是不是没有对['CumLatest', 'Quarterly', 'TTM']的不同数据进行处理？

- 从 ./Fundamental/raw/{指标名称}/{日期}.parquet 读取原始财务数据。

            数据包含列：CumLatest（累计值）、Quarterly（季度值）、TTM（滚动年度值）、DataDate（数据日期）、InnerCode（内部代码）等。

- 映射证券代码：读取 InnerCode 到 SecuCode 的映射关系，将财务数据的 InnerCode 转换为标准的 SecuCode（证券代码）

            删除无法映射到有效证券代码的行。

- 按财务期间处理数据（循环12次）

            subset = data.loc[data['EndDateRank']==i+1]    
            创建一个与 secucode 长度相同的空 DataFrame（用 NaN 填充）    
            如果证券代码在当前月份有数据，则填充；否则保持 NaN
  
- 拼接数据：排序后最终存储为结构化格式，传递给```save_Fundamental(new_data, date, feature_name)```

### save
```save_Fundamental(data, date, feature_name)```
- 对每列财务指标（累计值、季度值、滚动年度值）分别处理
-  提取关键列并重命名
  
            df = data[['DataDate', 'SecuCode', 'EndDateRank', col]]
   
            df = df.rename({col: '{}_{}'.format(feature_name, col)}, axis=1) 需要一点example
   
            将处理后的 DataFrame 保存为 Parquet 文件，路径格式为：
   
            df.to_parquet("./Fundamental/Lib/{}_{}/{}.parquet".format(feature_name, col, date), index=False)
```text
./Fundamental/Lib/
    ├── ROE_CumLatest/
    │   └── 20230812.parquet
    ├── ROE_Quarterly/
    │   └── 20230812.parquet
    └── ROE_TTM/
        └── 20230812.parquet
```

### read
```read_Fundamental(date, name)```:
         
            read_parquet("./Fundamental/Lib/{}/{}.parquet".format(name, date))

            data[name].values.reshape(-1, 12): 时间序列数据按固定窗口切分 (N,) -> (N//12, 12,)
            
            每行代表一个证券、每列代表一个月份
            
### DataProvider:

过抽象基类 Data_Provider 和具体子类 (ReturnDaily_Provider 和 Fundamental_Provider) 来统一管理不同数据源的下载处理获取

- 1. 抽象基类 Data_Provider
定义数据提供类的统一接口（download, get_data），强制子类必须实现这些方法。
直接实例化会报错 (NotImplementedError)，确保只能通过子类使用。

- 2. 子类 ReturnDaily_Provider（日频收益率数据）
根据交易日列表，从 OceanBase 逐日数据库下载 ReturnDaily 表（日频收益率数据），并保存为 Parquet 文件。

- 3. 子类 Fundamental_Provider（财务基本面数据）
        - "./Fundamental/raw" 存储原始数据；"./Fundamental/Lib" 存储处理后的数据
        - 为每个财务表创建目录 ：```./Fundamental/raw/{}".format(name)``` 并行下载数据
        - ```process```: 并行处理数据 process_Fundamental 负责数据清洗、对齐证券代码等操作。
        - ```get_data```:从磁盘加载数据

     data = p.starmap(read_Fundamental, tasks)  # 并行读取

     输入：tasks 是一个任务列表，每个任务为 (date, feature_name); 输出：data 是一个列表，包含每个特征对应的 DataFrame，如data = [df_roe, df_revenue] ， 每个df形状为 (证券数量, 时间维度=1)    

     data_list.append(np.asarray(data).transpose(1, 2, 0))  # 调整维度
     np.asarray(data)：将列表 data 转为 NumPy 数组，默认形状为 (特征数, 证券数, 时间维度)
     .transpose(1, 2, 0)：调整轴顺序，新形状为 (证券数, 时间维度, 特征数)
